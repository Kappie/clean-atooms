<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Atooms tutorial</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="style.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Atooms tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Basics</a>
<ul>
<li><a href="#sec-1-1">Particles' properties</a></li>
<li><a href="#sec-1-2">Dealing with velocities</a></li>
<li><a href="#sec-1-3">Boundary conditions</a></li>
<li><a href="#sec-1-4">The system object</a></li>
<li><a href="#sec-1-5">Trajectory files</a></li>
<li><a href="#sec-1-6">Particles on a lattice</a></li>
</ul>
</li>
<li><a href="#sec-2">Simulations</a>
<ul>
<li><a href="#sec-2-1">A minimal simulation backend</a></li>
<li><a href="#sec-2-2">Simple random walk</a></li>
<li><a href="#sec-2-3">Molecular dynamics with LAMMPS</a></li>
</ul>
</li>
<li><a href="#sec-3">Trajectories</a>
<ul>
<li><a href="#sec-3-1">Flexible trajectory output</a></li>
<li><a href="#sec-3-2">Conversion between trajectory formats</a></li>
<li><a href="#sec-3-3">Custom trajectory classes</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Basics</h2>
<div class="outline-text-2" id="text-1">

<p>
Atooms provides a high-level interface to the main objects of particle-based simulations. It mostly focuses on classical molecular dynamics and Monte Carlo simulations, but it is not limited to that. For instance, it can be used to model lattice models such as TASEP or kinetically constrained models.
</p>

<p>
We will start by having a look at the basic objects of particle-based simulations and how to store them on a file.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Particles' properties</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Particles' positions are stored as numpy arrays, but we can pass a simple list with x, y, z coordinates when we create them
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.system.particle <span style="color: #0000ff;">import</span> Particle
<span style="color: #000000;">particle</span> = Particle(position=[1.0, 0.0, 0.0])
<span style="color: #0000ff;">print</span>(particle.position, <span style="font-weight: bold;">type</span>(particle.position))
</pre>
</div>

<pre class="example">
Python 2.7.15rc1 (default, Nov 12 2018, 14:31:15) 
[GCC 7.3.0] on linux2
Type "help", "copyright", "credits" or "license" for more information.
(array([ 1.,  0.,  0.]), &lt;type 'numpy.ndarray'&gt;)
python.el: native completion setup loaded
</pre>

<p>
Particles can live in an arbitrary number of spatial dimensions
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #000000;">particle</span> = Particle(position=[1.0, 0.0, 0.0, 0.0, 0.0])
<span style="color: #0000ff;">print</span>(<span style="font-weight: bold;">len</span>(particle.position))
</pre>
</div>

<pre class="example">
5
</pre>

<p>
By default, they also have a few more properties such as velocity, chemical species, mass and radius. They can all be altered at will or even set to None.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">import</span> numpy
<span style="color: #000000;">particle</span> = Particle(position=[1.0, 0.0, 0.0], velocity=[1.0, 0.0, 0.0])
<span style="color: #000000;">particle.species</span> = <span style="font-style: italic;">'Na'</span>
<span style="color: #000000;">particle.position</span> += numpy.array([0.0, 1.0, 1.0])
<span style="color: #000000;">particle.velocity</span> *= 2
<span style="color: #000000;">particle.radius</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">point particles have no radius</span>
<span style="color: #0000ff;">print</span>(particle)
</pre>
</div>

<pre class="example">
Particle(species=Na, mass=1.0, position=[ 1.  1.  1.], velocity=[ 2.  0.  0.], radius=None)
</pre>

<p>
You may want to add physical properties to particles, like charge or whatever. Of course, in python you can do it very easily
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #000000;">particle.charge</span> = -1.0
</pre>
</div>

<p>
This won't break anything!
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Dealing with velocities</h3>
<div class="outline-text-3" id="text-1-2">
<p>
You may not need velocities at all (for instance because you are working with Monte Carlo simulations), but if you do, atooms provides a few useful methods and functions. For instance, you can assign velocity from a Maxwell-Boltzmann distribution at a temperature T.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #000000;">particle</span> = [Particle() <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(1000)]
<span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span> particle:
    p.maxwellian(T=1.0)
<span style="color: #000000;">ekin</span> = <span style="font-weight: bold;">sum</span>([p.kinetic_energy <span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span> particle])
<span style="color: #000000;">ndim</span> = 3
<span style="color: #000000;">ndof</span> = <span style="font-weight: bold;">len</span>(particle) * ndim
<span style="color: #000000;">T</span> = 2.0 / ndof * ekin
<span style="color: #0000ff;">print</span>(T)
</pre>
</div>

<pre class="example">
1.00345083328
</pre>

<p>
Doing so will leave a non-zero total momentum, but we can fix it (note that all masses are equal)
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.system.particle <span style="color: #0000ff;">import</span> fix_total_momentum, cm_velocity
<span style="color: #0000ff;">print</span>(cm_velocity(particle))
fix_total_momentum(particle)
<span style="color: #0000ff;">print</span>(cm_velocity(particle))
</pre>
</div>

<pre class="example">
[ 0.01834553  0.03018598 -0.04406148]
[ -3.08086889e-17  -6.55031585e-17  -3.85247390e-17]
</pre>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Boundary conditions</h3>
<div class="outline-text-3" id="text-1-3">
<p>
To avoid major finite size effects, we enclose particles in a cell with periodic boundary conditions. By convention, the cell origin is in the origin of the reference frame.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.system.cell <span style="color: #0000ff;">import</span> Cell
<span style="color: #000000;">L</span> = 2.0
<span style="color: #000000;">cell</span> = Cell(side=[L, L, L])
<span style="color: #0000ff;">print</span>(cell.side, cell.volume)
</pre>
</div>

<pre class="example">
(array([ 2.,  2.,  2.]), 8.0)
</pre>

<p>
Atooms provides means to fold particles back in the "central" simulation cell, i.e. the one centered at the origin at the reference frame. For simplicity, let us work with particles in 1d.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #000000;">cell</span> = Cell(side=1.0)
<span style="color: #000000;">particle</span> = Particle(position=2.0)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">particle outside the central cell</span>
particle.fold(cell)
<span style="color: #0000ff;">print</span>(particle.position)
</pre>
</div>

<pre class="example">
0.0
</pre>

<p>
The particle is now folded back at the origin.
</p>

<p>
A related method returns the nearest periodic image of a given particle with respect to another particle
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #000000;">particle_1</span> = Particle(position=-0.45)
<span style="color: #000000;">particle_2</span> = Particle(position=+0.45)
<span style="color: #000000;">image</span> = particle_1.nearest_image(particle_2, cell, copy=<span style="font-weight: bold; text-decoration: underline;">True</span>)
<span style="color: #0000ff;">print</span>(image)
</pre>
</div>

<pre class="example">
Particle(species=A, mass=1.0, position=0.55, velocity=[ 0.  0.  0.], radius=0.5)
</pre>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">The system object</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Objects like particles and the simulation cell can be gathered in an instance of a god-like class called System. The system contains all the relevant physical objects of your simulation. Reservoirs like thermostats, barostats and particle reservoirs can be added as well. These objects are placeholders for thermodynamic state variables like temperature, pressure or chemical potential. Any class meant to describe the interaction between particles also belongs to the system.
</p>

<p>
Let us build a system with a few particles in a cell and use the system methods to modify the system density and temperature. Note that density and temperature are python properties and thus modify the attributes of particles and cell under the hoods.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.system <span style="color: #0000ff;">import</span> System
<span style="color: #000000;">system</span> = System(particle=[Particle() <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(100)],
                cell=Cell([10.0, 10.0, 10.0]))
<span style="color: #000000;">system.density</span> = 1.2  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">equivalent to system.set_density(1.2)</span>
<span style="color: #000000;">system.temperature</span> = 1.5  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">equivalent to system.set_temperature(1.2)</span>
<span style="color: #0000ff;">print</span>(system.density, system.temperature)
</pre>
</div>

<pre class="example">
(1.1999999999999997, 1.4999999999999996)
</pre>

<p>
Note that the system temperature is the kinetic one and need not coincide with the one of the thermostat.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.system <span style="color: #0000ff;">import</span> Thermostat
<span style="color: #000000;">system.thermostat</span> = Thermostat(temperature=1.0)
<span style="color: #000000;">system.temperature</span> = 1.5  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">equivalent to system.set_temperature(1.2)</span>
<span style="color: #0000ff;">print</span>(system.temperature, system.thermostat.temperature)
</pre>
</div>

<pre class="example">
(1.5, 1.0)
</pre>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Trajectory files</h3>
<div class="outline-text-3" id="text-1-5">
<p>
To write the state of the system to a file, we use a <code>Trajectory</code> class. Trajectories are composed of multiple frames, each one holding the state of the system at a given step during the simulation. We use a basic xyz format to write the state of the system and then parse the trajectory file we produced to see how it looks like.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.trajectory <span style="color: #0000ff;">import</span> TrajectoryXYZ

<span style="color: #000000;">system</span> = System(particle=[Particle() <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(4)],
                cell=Cell([10.0, 10.0, 10.0]))

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Open the trajectory in write mode and write the state of the system</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">at step 0</span>
<span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>, <span style="font-style: italic;">'w'</span>) <span style="color: #0000ff;">as</span> th:
  th.write(system, step=0)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Read the xyz file back as plain text</span>
<span style="color: #0000ff;">with</span> <span style="font-weight: bold;">open</span>(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> fh:
  <span style="color: #0000ff;">print</span> fh.read()
</pre>
</div>

<pre class="example">
4
step:0 columns:id,pos dt:1 cell:10.0,10.0,10.0 
A 0.000000 0.000000 0.000000
A 0.000000 0.000000 0.000000
A 0.000000 0.000000 0.000000
A 0.000000 0.000000 0.000000
</pre>

<p>
Note that trajectories are file-like objects: they must be opened and closed, preferably using the <code>with</code> syntax.
</p>

<p>
Of course, we can write multiple frames by calling <code>write()</code> repeatedly.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>, <span style="font-style: italic;">'w'</span>) <span style="color: #0000ff;">as</span> th:
  <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(3):
    th.write(system, step=i*10)
</pre>
</div>

<p>
To get the system back we read the trajectory. Trajectories support iteration and indexing, just like lists.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> th:
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">First frame</span>
  <span style="color: #000000;">system</span> = th[0]
  <span style="color: #0000ff;">print</span>(system.particle[0].position, system.cell.side)

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Last frame</span>
  <span style="color: #000000;">system</span> = th[-1]
  <span style="color: #0000ff;">print</span>(system.particle[0].position, system.cell.side)

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Iterate over all frames</span>
  <span style="color: #0000ff;">for</span> i, system <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">enumerate</span>(th):
    <span style="color: #0000ff;">print</span>(th.steps[i], system.particle[0].position)
</pre>
</div>

<pre class="example">
(array([ 0.,  0.,  0.]), array([ 10.,  10.,  10.]))
(array([ 0.,  0.,  0.]), array([ 10.,  10.,  10.]))
(0, array([ 0.,  0.,  0.]))
(10, array([ 0.,  0.,  0.]))
(20, array([ 0.,  0.,  0.]))
</pre>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Particles on a lattice</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Say we want to simulate a system where particles can only be located at discrete sites, say a one-dimensional lattice or perhaps a network with a complex topology. Particle positions can be described as simple integers, holding the index of the site on which a particle is located. We create such a system and then write it to a file in xyz format
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">import</span> numpy
<span style="color: #0000ff;">from</span> atooms.system <span style="color: #0000ff;">import</span> System, Particle

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Build model system with integer coordinates</span>
<span style="color: #000000;">particle</span> = [Particle() <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(3)]
particle[0]<span style="color: #000000;">.position</span> = 0
particle[1]<span style="color: #000000;">.position</span> = 1
particle[2]<span style="color: #000000;">.position</span> = 2
<span style="color: #000000;">system</span> = System(particle=particle)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Write xyz trajectory</span>
<span style="color: #0000ff;">from</span> atooms.trajectory <span style="color: #0000ff;">import</span> TrajectoryXYZ
<span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>, <span style="font-style: italic;">'w'</span>) <span style="color: #0000ff;">as</span> th:
  th.write(system, 0)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Read the xyz file back as plain text</span>
<span style="color: #0000ff;">with</span> <span style="font-weight: bold;">open</span>(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> fh:
  <span style="color: #0000ff;">print</span>(fh.read())
</pre>
</div>

<pre class="example">
3
step:0 columns:id,pos dt:1 
A 0
A 1
A 2
</pre>

<p>
Everything went fine. However, we have to tweak things a bit when reading the particles back, to avoid positions being transformed to arrays of floats instead of integers. This can be done with the help of a callback that transforms the system accordingly as we read the trajectory.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Read file as an xyz trajectory </span>
<span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> th:

  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We add a callback to read positions as simple integers</span>
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Otherwise they are read as numpy arrays of floats.</span>
  <span style="color: #0000ff;">def</span> <span style="color: #0000ff; font-weight: bold;">modify</span>(system):      
    <span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span> system.particle:
      <span style="color: #000000;">p.position</span> = <span style="font-weight: bold;">int</span>(p.position[0])
      <span style="color: #000000;">p.velocity</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>
      <span style="color: #000000;">p.radius</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>
    <span style="color: #0000ff;">return</span> system
  th.add_callback(modify)

  <span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span> th[0].particle:
    <span style="color: #0000ff;">print</span> p
</pre>
</div>

<pre class="example">
Particle(species=A, mass=1.0, position=0, velocity=None, radius=None)
Particle(species=A, mass=1.0, position=1, velocity=None, radius=None)
Particle(species=A, mass=1.0, position=2, velocity=None, radius=None)
</pre>

<p>
Our particles have now integer coordinates. Note that, on passing, we have set to None velocities and radii as they are not relevant in this case.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Simulations</h2>
<div class="outline-text-2" id="text-2">
<p>
Within atooms, <b>Simulation</b> is a high-level classe that encapsulate some common tasks and provides a consistent interface to the user, while <b>Backends</b> are classes that actually make the system evolve. Here, we implement a minimal backend to run a simulation.
</p>

<p>
At a very minimum, a backend is a class that provides 
</p>

<ul class="org-ul">
<li>a <b>system</b> instance variable, which should (mostly) behave like <code>atooms.system.System</code>.
</li>
<li>a <b>run()</b> method, which evolves the system for a prescribed number of steps (passed as argument)
</li>
</ul>

<p>
Optionally, the backend may hold a reference to a trajectory class, which can be used to checkpoint the simulation or to write configurations to a file. This is however not required in a first stage.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">A minimal simulation backend</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We set up a bare-bones simulation backend building on the native System class
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.system <span style="color: #0000ff;">import</span> System

<span style="color: #0000ff;">class</span> <span style="color: #0000ff; font-weight: bold;">BareBonesBackend</span>(<span style="font-weight: bold;">object</span>):

    <span style="color: #0000ff;">def</span> <span style="color: #0000ff; font-weight: bold;">__init__</span>(<span style="color: #0000ff;">self</span>):
        <span style="color: #0000ff;">self</span>.system = System()

    <span style="color: #0000ff;">def</span> <span style="color: #0000ff; font-weight: bold;">run</span>(<span style="color: #0000ff;">self</span>, steps):
        <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(steps):
            <span style="color: #0000ff;">pass</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">The backend is created and wrapped by a simulation object.</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Here we first call the run() method then run_until()</span>
<span style="color: #0000ff;">from</span> atooms.simulation <span style="color: #0000ff;">import</span> Simulation
<span style="color: #000000;">backend</span> = BareBonesBackend()
<span style="color: #000000;">simulation</span> = Simulation(backend)
simulation.run(10)
simulation.run_until(30)
<span style="color: #0000ff;">assert</span> simulation.current_step == 30

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">This time we call run() multiple times </span>
<span style="color: #000000;">simulation</span> = Simulation(backend)
simulation.run(10)
simulation.run(20)
<span style="color: #0000ff;">assert</span> simulation.current_step == 30  

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Increase verbosity to see a meaningful log</span>
<span style="color: #0000ff;">from</span> atooms.core.utils <span style="color: #0000ff;">import</span> setup_logging
setup_logging(level=20)
<span style="color: #000000;">simulation</span> = Simulation(backend)
simulation.run(10)
</pre>
</div>

<pre class="example">
# 
# atooms simulation via &lt;__main__.BareBonesBackend object at 0x7fd31fe01710&gt;
# 
# version: 1.8.1+1.5.0-81-gdbd3fa (2019-02-13)
# atooms version: 1.8.1+1.5.0-81-gdbd3fa (2019-02-13)
# simulation started on: 2019-02-14 at 23:19
# output path: None
# backend: &lt;__main__.BareBonesBackend object at 0x7fd31fe01710&gt;
# 
# target target_steps: 10
# 
# 
# starting at step: 0
# 
# simulation ended successfully: reached target steps 10
# 
# final steps: 10
# final rmsd: 0.00
# wall time [s]: 0.00
# average TSP [s/step/particle]: nan
# simulation ended on: 2019-02-14 at 23:19
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Simple random walk</h3>
<div class="outline-text-3" id="text-2-2">
<p>
We implement a simple random walk in 3d. This requires adding code to the backend run() method to actually move the particles around.
</p>

<p>
We start by building an empty system. Then we add a few particles and place them at random in a cube. Finally, we write a backend that displaces each particle randomly over a cube of prescribed side.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">import</span> numpy
<span style="color: #0000ff;">from</span> atooms.system <span style="color: #0000ff;">import</span> System

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">There are no particles at the beginning</span>
<span style="color: #000000;">system</span> = System()
<span style="color: #0000ff;">assert</span> <span style="font-weight: bold;">len</span>(system.particle) == 0

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Add particles</span>
<span style="color: #0000ff;">from</span> atooms.system.particle <span style="color: #0000ff;">import</span> Particle
<span style="color: #0000ff;">from</span> random <span style="color: #0000ff;">import</span> random
<span style="color: #000000;">L</span> = 10
<span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(1000):
    <span style="color: #000000;">p</span> = Particle(position=[L * random(), L * random(), L * random()])
    system.particle.append(p)

<span style="color: #0000ff;">class</span> <span style="color: #0000ff; font-weight: bold;">RandomWalk</span>(<span style="font-weight: bold;">object</span>):

    <span style="color: #0000ff;">def</span> <span style="color: #0000ff; font-weight: bold;">__init__</span>(<span style="color: #0000ff;">self</span>, system, delta=1.0):
        <span style="color: #0000ff;">self</span>.system = system
        <span style="color: #0000ff;">self</span>.delta = delta

    <span style="color: #0000ff;">def</span> <span style="color: #0000ff; font-weight: bold;">run</span>(<span style="color: #0000ff;">self</span>, steps):
        <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">range</span>(steps):
            <span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">self</span>.system.particle:
                <span style="color: #000000;">dr</span> = numpy.array([random()-0.5, random()-0.5, random()-0.5])
                <span style="color: #000000;">dr</span> *= <span style="color: #0000ff;">self</span>.delta
                <span style="color: #000000;">p.position</span> += dr
</pre>
</div>

<p>
The Simulation class provides a callback mechanism to allow execution of arbitrary code during the simulation. This can be used to write logs or particle configurations to file, or to perform on-the-fly calculations of the system properties. Callbacks are plain function that accept the simulation object as first argument. They are called at prescribed intervals during the simulation.
</p>

<p>
Here we measure the mean square displacement (MSD) of the particles to make sure that the system displays a regular diffusive behavior \(MSD \sim t\)
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.simulation <span style="color: #0000ff;">import</span> Simulation
<span style="color: #000000;">simulation</span> = Simulation(RandomWalk(system))

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We add a callback that computes the MSD every 10 steps</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We store the result in a dictionary passed to the callback</span>
<span style="color: #000000;">msd_db</span> = {}
<span style="color: #0000ff;">def</span> <span style="color: #0000ff; font-weight: bold;">cbk</span>(sim, initial_position, db):
    <span style="color: #000000;">msd</span> = 0.0
    <span style="color: #0000ff;">for</span> i, p <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">enumerate</span>(sim.system.particle):
        <span style="color: #000000;">dr</span> = p.position - initial_position[i]
        <span style="color: #000000;">msd</span> += numpy.<span style="font-weight: bold;">sum</span>(dr**2)
    <span style="color: #000000;">msd</span> /= <span style="font-weight: bold;">len</span>(sim.system.particle)
    <span style="color: #000000;">db</span>[sim.current_step] = msd

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We will execute the callback every 10 steps</span>
simulation.add(cbk, 10, initial_position=[p.position.copy() <span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span>
                                          system.particle], db=msd_db)
simulation.run(50)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">The MSD should increase linearly with time</span>
<span style="color: #000000;">time</span> = <span style="font-weight: bold;">sorted</span>(msd_db.keys())
<span style="color: #000000;">msd</span> = [msd_db[t] <span style="color: #0000ff;">for</span> t <span style="color: #0000ff;">in</span> time]

<span style="color: #0000ff;">print</span> time, msd
<span style="color: #0000ff;">import</span> matplotlib.pyplot <span style="color: #0000ff;">as</span> plt
plt.cla()
plt.plot(time, msd, <span style="font-style: italic;">'-o'</span>)
plt.xlabel(<span style="font-style: italic;">"t"</span>)
plt.ylabel(<span style="font-style: italic;">"MSD"</span>)
plt.savefig(<span style="font-style: italic;">'msd.png'</span>)
</pre>
</div>

<pre class="example">
[0, 10, 20, 30, 40, 50] [0.0, 2.4943569776866177, 5.2325902471271366, 7.6552858849199135, 10.603602692677358, 12.854339346154946]
</pre>

<p>
The MSD as a function of time should look linear.
<img src="msd.png" alt="msd.png" />
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Molecular dynamics with LAMMPS</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Atooms provides a simulation backend for LAMMPS, an efficient and feature-rich molecular dynamics simulation package.
The backend accepts a string variable containing regular LAMMPS commands and a trajectory that provides the starting configuration for the simulation.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">import</span> atooms.trajectory <span style="color: #0000ff;">as</span> trj
<span style="color: #0000ff;">from</span> atooms.backends.lammps <span style="color: #0000ff;">import</span> LAMMPS

<span style="color: #0000ff;">import</span> os
<span style="color: #000000;">inp</span> = trj.TrajectoryXYZ(<span style="font-style: italic;">'../../data/lj_N1000_rho1.0.xyz'</span>)
<span style="color: #000000;">cmd</span> = <span style="font-style: italic;">"""</span>
<span style="font-style: italic;">pair_style      lj/cut 2.5</span>
<span style="font-style: italic;">pair_coeff      1 1 1.0 1.0  2.5</span>
<span style="font-style: italic;">neighbor        0.3 bin</span>
<span style="font-style: italic;">neigh_modify    check yes</span>
<span style="font-style: italic;">timestep        0.002</span>
<span style="font-style: italic;">"""</span>
<span style="color: #000000;">backend</span> = LAMMPS(inp, cmd)
</pre>
</div>

<p>
We now wrap the backend in a simulation instance. This way we can rely on atooms to write thermodynamic data and configurations to disk during the simulation: we just add the <code>write_config()</code> and <code>write_thermo()</code> functions as observers to the simulations.
You can add your own functions as observers to perform arbitrary manipulations on the system during the simulation. Keep in mind that calling these functions causes some overhead, so avoid calling them at too short intervals.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.simulation <span style="color: #0000ff;">import</span> Simulation
<span style="color: #0000ff;">from</span> atooms.system <span style="color: #0000ff;">import</span> Thermostat
<span style="color: #0000ff;">from</span> atooms.simulation.observers <span style="color: #0000ff;">import</span> write_thermo, write_config

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We create the simulation instance and set the output path</span>
<span style="color: #000000;">sim</span> = Simulation(backend, output_path=<span style="font-style: italic;">'lammps.xyz'</span>)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Just store a reference to the trajectory class you want to use</span>
<span style="color: #000000;">sim.trajectory</span> = trj.TrajectoryXYZ
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Write configurations every 500 steps in xyz format</span>
sim.add(write_config, 500)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Write thermodynamic properties every 500 steps</span>
sim.add(write_thermo, 500)
</pre>
</div>

<p>
We add a thermostat to keep the system temperature at T=2.0 and run the simulations for 10000 steps.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #000000;">backend.system.thermostat</span> = Thermostat(temperature=2.0, relaxation_time=1.0)
sim.run(10000)
</pre>
</div>

<p>
Note that we use atooms <code>Thermostat</code> object here: the backend will take care of adding appropriate commands to the LAMMPS script.
</p>

<p>
We have a quick look at the kinetic temperature as function of time to make sure the thermostat is working
</p>
<div class="org-src-container">

<pre class="src src-gnuplot"><span style="font-weight: bold; text-decoration: underline;">set</span> xl <span style="font-style: italic;">'Steps'</span>
<span style="font-weight: bold; text-decoration: underline;">set</span> yl <span style="font-style: italic;">'Temperature'</span>
<span style="font-weight: bold; text-decoration: underline;">set</span> border 3
<span style="font-weight: bold; text-decoration: underline;">set</span> xtics nomirror
<span style="font-weight: bold; text-decoration: underline;">set</span> ytics nomirror
<span style="color: #0000ff;">plot</span> <span style="font-style: italic;">'lammps.xyz.thermo'</span> u 1:2 noti w lp lc rgb <span style="font-style: italic;">'red'</span> <span style="color: #0000ff; font-weight: bold;">pt</span> 7, 2 noti lc rgb <span style="font-style: italic;">'black'</span>
</pre>
</div>

<p>
We can use the postprocessing package to compute the radial distribution function
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.postprocessing <span style="color: #0000ff;">import</span> api
api.gr(<span style="font-style: italic;">'lammps.xyz'</span>)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-gnuplot"><span style="font-weight: bold; text-decoration: underline;">set</span> xl <span style="font-style: italic;">'r'</span>
<span style="font-weight: bold; text-decoration: underline;">set</span> yl <span style="font-style: italic;">'g(r)'</span>
<span style="font-weight: bold; text-decoration: underline;">set</span> border 3
<span style="font-weight: bold; text-decoration: underline;">set</span> xtics nomirror
<span style="font-weight: bold; text-decoration: underline;">set</span> ytics nomirror
<span style="color: #0000ff;">plot</span> <span style="font-style: italic;">'lammps.xyz.pp.gr'</span> u 1:2 noti w lp lc rgb <span style="font-style: italic;">'red'</span> <span style="color: #0000ff; font-weight: bold;">pt</span> 7
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Trajectories</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Flexible trajectory output</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We can customize the format of trajectory files using the <code>fields</code> variable. It contains a list of the particle properties to be written to the trajectory. For this simple example we use again the xyz trajectory format.
</p>

<p>
We add a <code>charge</code> property to each particle and then instruct the trajectory to write it along with the position
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">for</span> p <span style="color: #0000ff;">in</span> system.particle:
  <span style="color: #000000;">p.charge</span> = -1.0

<span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>, <span style="font-style: italic;">'w'</span>, fields=[<span style="font-style: italic;">'position'</span>, <span style="font-style: italic;">'charge'</span>]) <span style="color: #0000ff;">as</span> th:
  th.write(system, step=0)

<span style="color: #0000ff;">with</span> <span style="font-weight: bold;">open</span>(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> fh:
  <span style="color: #0000ff;">print</span> fh.read()
</pre>
</div>

<pre class="example">
4
step:0 columns:position,charge dt:1 cell:10.0,10.0,10.0 
0.000000 0.000000 0.000000 -1.0
0.000000 0.000000 0.000000 -1.0
0.000000 0.000000 0.000000 -1.0
0.000000 0.000000 0.000000 -1.0
</pre>

<p>
The <code>fields</code> list can contain any particle property, even those defined dynamically at run time, such as the <code>charge</code> variable above which is not a predefined particle property!. When reading back the trajectory, the <code>charge</code> property is automatically recognized and added to the particle. 
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> th:
  <span style="color: #000000;">system</span> = th[0]
  <span style="color: #0000ff;">print</span>(system.particle[0].charge)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Conversion between trajectory formats</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Atooms provides means to convert between trajectory various formats. At a very basic level, this requires opening the original trajectory for reading and the new one for writing using the desired trajectory class. Here we convert an xyz trajectory in a format suitable for the LAMMPS package
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">with</span> TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>) <span style="color: #0000ff;">as</span> th_inp,\
     TrajectoryLAMMPS(<span style="font-style: italic;">'test.lammps'</span>, <span style="font-style: italic;">'w'</span>) <span style="color: #0000ff;">as</span> th_out:
  <span style="color: #0000ff;">for</span> i, system <span style="color: #0000ff;">in</span> <span style="font-weight: bold;">enumerate</span>(th_inp):
    th_out.write(system, th_inp.steps[i])
</pre>
</div>

<p>
The <code>convert()</code> function wraps the conversion in a more convenient interface
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000ff;">from</span> atooms.trajectory <span style="color: #0000ff;">import</span> convert
convert(TrajectoryXYZ(<span style="font-style: italic;">'test.xyz'</span>), TrajectoryLAMMPS, <span style="font-style: italic;">'test.lammps'</span>)
</pre>
</div>
<p>
There are several optional parameters that allows to customize the trajectory output, see the function signature for more details.
</p>

<p>
Finally, the <code>trj.py</code> script installed by atooms allows to quickly convert trajectories on the command-line, which is actually the most frequent use case
</p>
<div class="org-src-container">

<pre class="src src-sh">trj.py convert -i xyz -o lammps test.xyz test.lammps
</pre>
</div>

<p>
Although the script will do its best to guess the appropriate trajectory formats, it is best to provide the input and output trajectory formats via the <code>-i</code> and <code>-o</code> flags explicitly.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Custom trajectory classes</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
